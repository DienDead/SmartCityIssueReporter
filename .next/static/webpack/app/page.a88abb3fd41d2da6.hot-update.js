"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./services/reports-service.ts":
/*!*************************************!*\
  !*** ./services/reports-service.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addReport: () => (/* binding */ addReport),\n/* harmony export */   classifyReport: () => (/* binding */ classifyReport),\n/* harmony export */   getReports: () => (/* binding */ getReports),\n/* harmony export */   removeReport: () => (/* binding */ removeReport),\n/* harmony export */   updateReportStatus: () => (/* binding */ updateReportStatus)\n/* harmony export */ });\n/* harmony import */ var _lib_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/id */ \"(app-pages-browser)/./lib/id.ts\");\n/* __next_internal_client_entry_do_not_use__ getReports,addReport,updateReportStatus,removeReport,classifyReport auto */ \n// Storage\nconst STORAGE_KEY = \"smart_city_reports_v1\";\nfunction read() {\n    try {\n        const raw = localStorage.getItem(STORAGE_KEY);\n        if (!raw) {\n            const seeded = seedReports();\n            localStorage.setItem(STORAGE_KEY, JSON.stringify(seeded));\n            return seeded;\n        }\n        return JSON.parse(raw);\n    } catch (e) {\n        return [];\n    }\n}\nfunction write(reports) {\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(reports));\n}\n// Public API\nasync function getReports() {\n    return read();\n}\nasync function addReport(input) {\n    const reports = read();\n    var _input_autoCategorized;\n    const report = {\n        id: (0,_lib_id__WEBPACK_IMPORTED_MODULE_0__.nanoid)(),\n        title: input.title,\n        description: input.description,\n        category: input.category,\n        autoCategorized: (_input_autoCategorized = input.autoCategorized) !== null && _input_autoCategorized !== void 0 ? _input_autoCategorized : false,\n        status: \"open\",\n        lat: input.lat,\n        lng: input.lng,\n        imageDataUrl: input.imageDataUrl,\n        createdAt: new Date().toISOString()\n    };\n    reports.push(report);\n    write(reports);\n    const res = await fetch(\"/\", {\n        method: \"POST\",\n        body: JSON.stringify(report)\n    });\n    return report;\n}\nasync function updateReportStatus(id, status) {\n    const reports = read();\n    const idx = reports.findIndex((r)=>r.id === id);\n    if (idx >= 0) {\n        reports[idx].status = status;\n        write(reports);\n    }\n}\nasync function removeReport(id) {\n    const reports = read().filter((r)=>r.id !== id);\n    write(reports);\n}\n// Classification\nasync function classifyReport(params) {\n    var _params_title, _params_description;\n    const text = \"\".concat((_params_title = params.title) !== null && _params_title !== void 0 ? _params_title : \"\", \" \").concat((_params_description = params.description) !== null && _params_description !== void 0 ? _params_description : \"\").toLowerCase();\n    const keywordMatch = keywordClassifier(text);\n    if (keywordMatch) {\n        await delay(300);\n        return {\n            category: keywordMatch.category,\n            confidence: 0.92,\n            reason: keywordMatch.reason\n        };\n    }\n    // Weak default\n    await delay(400);\n    return {\n        category: \"other\",\n        confidence: 0.4,\n        reason: \"No strong signal found from text or image\"\n    };\n}\nfunction keywordClassifier(text) {\n    const hit = (words)=>words.some((w)=>text.includes(w));\n    if (hit([\n        \"pothole\",\n        \"potholes\",\n        \"road hole\",\n        \"asphalt\",\n        \"crack\",\n        \"cracked road\",\n        \"damaged road\"\n    ])) {\n        return {\n            category: \"pothole\",\n            reason: \"Matched pothole-related keywords\"\n        };\n    }\n    if (hit([\n        \"garbage\",\n        \"trash\",\n        \"waste\",\n        \"dump\",\n        \"litter\",\n        \"bin overflow\",\n        \"overflowing\"\n    ])) {\n        return {\n            category: \"garbage\",\n            reason: \"Matched garbage-related keywords\"\n        };\n    }\n    return null;\n}\n// async function averageBrightness(file: File): Promise<number> {\n//   const url = URL.createObjectURL(file)\n//   try {\n//     const img = await loadImage(url)\n//     const { width, height } = img\n//     const canvas = document.createElement(\"canvas\")\n//     canvas.width = 64\n//     canvas.height = 64\n//     const ctx = canvas.getContext(\"2d\")\n//     if (!ctx) throw new Error(\"Canvas not supported\")\n//     // Draw scaled thumbnail to speed up\n//     ctx.drawImage(img, 0, 0, canvas.width, canvas.height)\n//     const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data\n//     let sum = 0\n//     for (let i = 0; i < data.length; i += 4) {\n//       const r = data[i]\n//       const g = data[i + 1]\n//       const b = data[i + 2]\n//       // perceived luminance\n//       const y = 0.2126 * r + 0.7152 * g + 0.0722 * b\n//       sum += y\n//     }\n//     const avg = sum / (data.length / 4)\n//     return avg\n//   } finally {\n//     URL.revokeObjectURL(url)\n//   }\n// }\nfunction loadImage(src) {\n    return new Promise((resolve, reject)=>{\n        const img = new Image();\n        img.crossOrigin = \"anonymous\";\n        img.onload = ()=>resolve(img);\n        img.onerror = (e)=>reject(e);\n        img.src = src;\n    });\n}\nfunction delay(ms) {\n    return new Promise((res)=>setTimeout(res, ms));\n}\n// Seed data to visualize heatmap on first load\nfunction seedReports() {\n    const base = [\n        {\n            title: \"Pothole near Connaught Place\",\n            description: \"Large pothole causing traffic slowdown.\",\n            category: \"pothole\",\n            autoCategorized: true,\n            status: \"open\",\n            lat: 28.6315,\n            lng: 77.2167,\n            imageDataUrl: \"\"\n        },\n        {\n            title: \"Overflowing garbage bin\",\n            description: \"Needs immediate cleanup.\",\n            category: \"garbage\",\n            autoCategorized: true,\n            status: \"in_progress\",\n            lat: 28.6448,\n            lng: 77.2167,\n            imageDataUrl: \"\"\n        }\n    ];\n    const now = Date.now();\n    const reports = base.map((b, i)=>({\n            ...b,\n            id: (0,_lib_id__WEBPACK_IMPORTED_MODULE_0__.nanoid)(),\n            createdAt: new Date(now - i * 1000 * 60 * 60 * 12).toISOString()\n        }));\n    // Add a few random points around center\n    const center = {\n        lat: 28.6139,\n        lng: 77.209\n    };\n    for(let i = 0; i < 20; i++){\n        const jitter = (max)=>(Math.random() - 0.5) * max;\n        const cats = [\n            \"pothole\",\n            \"garbage\",\n            \"other\"\n        ];\n        const cat = cats[Math.floor(Math.random() * cats.length)];\n        reports.push({\n            id: (0,_lib_id__WEBPACK_IMPORTED_MODULE_0__.nanoid)(),\n            title: \"Sample report\",\n            description: \"Seeded demo data\",\n            category: cat,\n            autoCategorized: true,\n            status: Math.random() < 0.2 ? \"resolved\" : Math.random() < 0.6 ? \"open\" : \"in_progress\",\n            lat: center.lat + jitter(0.12),\n            lng: center.lng + jitter(0.12),\n            imageDataUrl: \"\",\n            createdAt: new Date(now - Math.floor(Math.random() * 1000 * 60 * 60 * 24 * 20)).toISOString()\n        });\n    }\n    return reports;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL3JlcG9ydHMtc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7eUhBRW1DO0FBS25DLFVBQVU7QUFDVixNQUFNQyxjQUFjO0FBRXBCLFNBQVNDO0lBQ1AsSUFBSTtRQUNGLE1BQU1DLE1BQU1DLGFBQWFDLE9BQU8sQ0FBQ0o7UUFDakMsSUFBSSxDQUFDRSxLQUFLO1lBQ1IsTUFBTUcsU0FBU0M7WUFDZkgsYUFBYUksT0FBTyxDQUFDUCxhQUFhUSxLQUFLQyxTQUFTLENBQUNKO1lBQ2pELE9BQU9BO1FBQ1Q7UUFDQSxPQUFPRyxLQUFLRSxLQUFLLENBQUNSO0lBQ3BCLEVBQUUsVUFBTTtRQUNOLE9BQU8sRUFBRTtJQUNYO0FBQ0Y7QUFFQSxTQUFTUyxNQUFNQyxPQUFpQjtJQUM5QlQsYUFBYUksT0FBTyxDQUFDUCxhQUFhUSxLQUFLQyxTQUFTLENBQUNHO0FBQ25EO0FBRUEsYUFBYTtBQUNOLGVBQWVDO0lBQ3BCLE9BQU9aO0FBQ1Q7QUFFTyxlQUFlYSxVQUNwQkMsS0FBb0M7SUFFcEMsTUFBTUgsVUFBVVg7UUFNR2M7SUFMbkIsTUFBTUMsU0FBaUI7UUFDckJDLElBQUlsQiwrQ0FBTUE7UUFDVm1CLE9BQU9ILE1BQU1HLEtBQUs7UUFDbEJDLGFBQWFKLE1BQU1JLFdBQVc7UUFDOUJDLFVBQVVMLE1BQU1LLFFBQVE7UUFDeEJDLGlCQUFpQk4sQ0FBQUEseUJBQUFBLE1BQU1NLGVBQWUsY0FBckJOLG9DQUFBQSx5QkFBeUI7UUFDMUNPLFFBQVE7UUFDUkMsS0FBS1IsTUFBTVEsR0FBRztRQUNkQyxLQUFLVCxNQUFNUyxHQUFHO1FBQ2RDLGNBQWNWLE1BQU1VLFlBQVk7UUFDaENDLFdBQVcsSUFBSUMsT0FBT0MsV0FBVztJQUNuQztJQUNBaEIsUUFBUWlCLElBQUksQ0FBQ2I7SUFDYkwsTUFBTUM7SUFFTixNQUFNa0IsTUFBTSxNQUFNQyxNQUFNLEtBQUs7UUFDM0JDLFFBQVE7UUFDUkMsTUFBTXpCLEtBQUtDLFNBQVMsQ0FBQ087SUFDdkI7SUFFQSxPQUFPQTtBQUNUO0FBRU8sZUFBZWtCLG1CQUNwQmpCLEVBQVUsRUFDVkssTUFBZ0M7SUFFaEMsTUFBTVYsVUFBVVg7SUFDaEIsTUFBTWtDLE1BQU12QixRQUFRd0IsU0FBUyxDQUFDLENBQUNDLElBQU1BLEVBQUVwQixFQUFFLEtBQUtBO0lBQzlDLElBQUlrQixPQUFPLEdBQUc7UUFDWnZCLE9BQU8sQ0FBQ3VCLElBQUksQ0FBQ2IsTUFBTSxHQUFHQTtRQUN0QlgsTUFBTUM7SUFDUjtBQUNGO0FBRU8sZUFBZTBCLGFBQWFyQixFQUFVO0lBQzNDLE1BQU1MLFVBQVVYLE9BQU9zQyxNQUFNLENBQUMsQ0FBQ0YsSUFBTUEsRUFBRXBCLEVBQUUsS0FBS0E7SUFDOUNOLE1BQU1DO0FBQ1I7QUFFQSxpQkFBaUI7QUFDVixlQUFlNEIsZUFBZUMsTUFJcEM7UUFLaUJBLGVBQ2RBO0lBREYsTUFBTUMsT0FBTyxHQUNYRCxPQURjQSxDQUFBQSxnQkFBQUEsT0FBT3ZCLEtBQUssY0FBWnVCLDJCQUFBQSxnQkFBZ0IsSUFBRyxLQUVsQyxPQURDQSxDQUFBQSxzQkFBQUEsT0FBT3RCLFdBQVcsY0FBbEJzQixpQ0FBQUEsc0JBQXNCLElBQ3JCRSxXQUFXO0lBQ2QsTUFBTUMsZUFBZUMsa0JBQWtCSDtJQUN2QyxJQUFJRSxjQUFjO1FBQ2hCLE1BQU1FLE1BQU07UUFDWixPQUFPO1lBQ0wxQixVQUFVd0IsYUFBYXhCLFFBQVE7WUFDL0IyQixZQUFZO1lBQ1pDLFFBQVFKLGFBQWFJLE1BQU07UUFDN0I7SUFDRjtJQUVBLGVBQWU7SUFDZixNQUFNRixNQUFNO0lBQ1osT0FBTztRQUNMMUIsVUFBVTtRQUNWMkIsWUFBWTtRQUNaQyxRQUFRO0lBQ1Y7QUFDRjtBQUVBLFNBQVNILGtCQUNQSCxJQUFZO0lBRVosTUFBTU8sTUFBTSxDQUFDQyxRQUFvQkEsTUFBTUMsSUFBSSxDQUFDLENBQUNDLElBQU1WLEtBQUtXLFFBQVEsQ0FBQ0Q7SUFDakUsSUFDRUgsSUFBSTtRQUNGO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0QsR0FDRDtRQUNBLE9BQU87WUFBRTdCLFVBQVU7WUFBVzRCLFFBQVE7UUFBbUM7SUFDM0U7SUFDQSxJQUNFQyxJQUFJO1FBQ0Y7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDRCxHQUNEO1FBQ0EsT0FBTztZQUFFN0IsVUFBVTtZQUFXNEIsUUFBUTtRQUFtQztJQUMzRTtJQUNBLE9BQU87QUFDVDtBQUVBLGtFQUFrRTtBQUNsRSwwQ0FBMEM7QUFDMUMsVUFBVTtBQUNWLHVDQUF1QztBQUN2QyxvQ0FBb0M7QUFDcEMsc0RBQXNEO0FBQ3RELHdCQUF3QjtBQUN4Qix5QkFBeUI7QUFDekIsMENBQTBDO0FBQzFDLHdEQUF3RDtBQUN4RCwyQ0FBMkM7QUFDM0MsNERBQTREO0FBQzVELDRFQUE0RTtBQUM1RSxrQkFBa0I7QUFDbEIsaURBQWlEO0FBQ2pELDBCQUEwQjtBQUMxQiw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCLCtCQUErQjtBQUMvQix1REFBdUQ7QUFDdkQsaUJBQWlCO0FBQ2pCLFFBQVE7QUFDUiwwQ0FBMEM7QUFDMUMsaUJBQWlCO0FBQ2pCLGdCQUFnQjtBQUNoQiwrQkFBK0I7QUFDL0IsTUFBTTtBQUNOLElBQUk7QUFFSixTQUFTTSxVQUFVQyxHQUFXO0lBQzVCLE9BQU8sSUFBSUMsUUFBUSxDQUFDQyxTQUFTQztRQUMzQixNQUFNQyxNQUFNLElBQUlDO1FBQ2hCRCxJQUFJRSxXQUFXLEdBQUc7UUFDbEJGLElBQUlHLE1BQU0sR0FBRyxJQUFNTCxRQUFRRTtRQUMzQkEsSUFBSUksT0FBTyxHQUFHLENBQUNDLElBQU1OLE9BQU9NO1FBQzVCTCxJQUFJSixHQUFHLEdBQUdBO0lBQ1o7QUFDRjtBQUVBLFNBQVNULE1BQU1tQixFQUFVO0lBQ3ZCLE9BQU8sSUFBSVQsUUFBUSxDQUFDMUIsTUFBUW9DLFdBQVdwQyxLQUFLbUM7QUFDOUM7QUFFQSwrQ0FBK0M7QUFDL0MsU0FBUzNEO0lBQ1AsTUFBTTZELE9BQTJDO1FBQy9DO1lBQ0VqRCxPQUFPO1lBQ1BDLGFBQWE7WUFDYkMsVUFBVTtZQUNWQyxpQkFBaUI7WUFDakJDLFFBQVE7WUFDUkMsS0FBSztZQUNMQyxLQUFLO1lBQ0xDLGNBQWM7UUFDaEI7UUFDQTtZQUNFUCxPQUFPO1lBQ1BDLGFBQWE7WUFDYkMsVUFBVTtZQUNWQyxpQkFBaUI7WUFDakJDLFFBQVE7WUFDUkMsS0FBSztZQUNMQyxLQUFLO1lBQ0xDLGNBQWM7UUFDaEI7S0FDRDtJQUNELE1BQU0yQyxNQUFNekMsS0FBS3lDLEdBQUc7SUFDcEIsTUFBTXhELFVBQW9CdUQsS0FBS0UsR0FBRyxDQUFDLENBQUNDLEdBQUdDLElBQU87WUFDNUMsR0FBR0QsQ0FBQztZQUNKckQsSUFBSWxCLCtDQUFNQTtZQUNWMkIsV0FBVyxJQUFJQyxLQUFLeUMsTUFBTUcsSUFBSSxPQUFPLEtBQUssS0FBSyxJQUFJM0MsV0FBVztRQUNoRTtJQUNBLHdDQUF3QztJQUN4QyxNQUFNNEMsU0FBUztRQUFFakQsS0FBSztRQUFTQyxLQUFLO0lBQU87SUFDM0MsSUFBSyxJQUFJK0MsSUFBSSxHQUFHQSxJQUFJLElBQUlBLElBQUs7UUFDM0IsTUFBTUUsU0FBUyxDQUFDQyxNQUFnQixDQUFDQyxLQUFLQyxNQUFNLEtBQUssR0FBRSxJQUFLRjtRQUN4RCxNQUFNRyxPQUE2QjtZQUFDO1lBQVc7WUFBVztTQUFRO1FBQ2xFLE1BQU1DLE1BQU1ELElBQUksQ0FBQ0YsS0FBS0ksS0FBSyxDQUFDSixLQUFLQyxNQUFNLEtBQUtDLEtBQUtHLE1BQU0sRUFBRTtRQUN6RHBFLFFBQVFpQixJQUFJLENBQUM7WUFDWFosSUFBSWxCLCtDQUFNQTtZQUNWbUIsT0FBTztZQUNQQyxhQUFhO1lBQ2JDLFVBQVUwRDtZQUNWekQsaUJBQWlCO1lBQ2pCQyxRQUNFcUQsS0FBS0MsTUFBTSxLQUFLLE1BQ1osYUFDQUQsS0FBS0MsTUFBTSxLQUFLLE1BQ2hCLFNBQ0E7WUFDTnJELEtBQUtpRCxPQUFPakQsR0FBRyxHQUFHa0QsT0FBTztZQUN6QmpELEtBQUtnRCxPQUFPaEQsR0FBRyxHQUFHaUQsT0FBTztZQUN6QmhELGNBQWM7WUFDZEMsV0FBVyxJQUFJQyxLQUNieUMsTUFBTU8sS0FBS0ksS0FBSyxDQUFDSixLQUFLQyxNQUFNLEtBQUssT0FBTyxLQUFLLEtBQUssS0FBSyxLQUN2RGhELFdBQVc7UUFDZjtJQUNGO0lBQ0EsT0FBT2hCO0FBQ1QiLCJzb3VyY2VzIjpbIkU6XFxQUk9KRUNUU1xcN3RoIFNlbWVzdGVyXFxTbWFydC1DaXR5LUlzc3VlLVJlcG9ydGVyLS1tYWluXFxzZXJ2aWNlc1xccmVwb3J0cy1zZXJ2aWNlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5pbXBvcnQgeyBuYW5vaWQgfSBmcm9tIFwiLi4vbGliL2lkXCI7XG5pbXBvcnQgdHlwZSB7IFJlcG9ydCB9IGZyb20gXCIuL3R5cGVzXCI7XG5leHBvcnQgdHlwZSB7IFJlcG9ydCB9IGZyb20gXCIuL3R5cGVzXCI7XG5leHBvcnQgdHlwZSB7IENhdGVnb3J5LCBTdGF0dXMsIFJlcG9ydElucHV0IH0gZnJvbSBcIi4vdHlwZXNcIjtcblxuLy8gU3RvcmFnZVxuY29uc3QgU1RPUkFHRV9LRVkgPSBcInNtYXJ0X2NpdHlfcmVwb3J0c192MVwiO1xuXG5mdW5jdGlvbiByZWFkKCk6IFJlcG9ydFtdIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByYXcgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX0tFWSk7XG4gICAgaWYgKCFyYXcpIHtcbiAgICAgIGNvbnN0IHNlZWRlZCA9IHNlZWRSZXBvcnRzKCk7XG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkoc2VlZGVkKSk7XG4gICAgICByZXR1cm4gc2VlZGVkO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5wYXJzZShyYXcpIGFzIFJlcG9ydFtdO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuZnVuY3Rpb24gd3JpdGUocmVwb3J0czogUmVwb3J0W10pIHtcbiAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KHJlcG9ydHMpKTtcbn1cblxuLy8gUHVibGljIEFQSVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFJlcG9ydHMoKTogUHJvbWlzZTxSZXBvcnRbXT4ge1xuICByZXR1cm4gcmVhZCgpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYWRkUmVwb3J0KFxuICBpbnB1dDogaW1wb3J0KFwiLi90eXBlc1wiKS5SZXBvcnRJbnB1dFxuKTogUHJvbWlzZTxSZXBvcnQ+IHtcbiAgY29uc3QgcmVwb3J0cyA9IHJlYWQoKTtcbiAgY29uc3QgcmVwb3J0OiBSZXBvcnQgPSB7XG4gICAgaWQ6IG5hbm9pZCgpLFxuICAgIHRpdGxlOiBpbnB1dC50aXRsZSxcbiAgICBkZXNjcmlwdGlvbjogaW5wdXQuZGVzY3JpcHRpb24sXG4gICAgY2F0ZWdvcnk6IGlucHV0LmNhdGVnb3J5LFxuICAgIGF1dG9DYXRlZ29yaXplZDogaW5wdXQuYXV0b0NhdGVnb3JpemVkID8/IGZhbHNlLFxuICAgIHN0YXR1czogXCJvcGVuXCIsXG4gICAgbGF0OiBpbnB1dC5sYXQsXG4gICAgbG5nOiBpbnB1dC5sbmcsXG4gICAgaW1hZ2VEYXRhVXJsOiBpbnB1dC5pbWFnZURhdGFVcmwsXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gIH07XG4gIHJlcG9ydHMucHVzaChyZXBvcnQpO1xuICB3cml0ZShyZXBvcnRzKTtcblxuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChcIi9cIiwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkocmVwb3J0KSxcbiAgfSk7XG5cbiAgcmV0dXJuIHJlcG9ydDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVJlcG9ydFN0YXR1cyhcbiAgaWQ6IHN0cmluZyxcbiAgc3RhdHVzOiBpbXBvcnQoXCIuL3R5cGVzXCIpLlN0YXR1c1xuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHJlcG9ydHMgPSByZWFkKCk7XG4gIGNvbnN0IGlkeCA9IHJlcG9ydHMuZmluZEluZGV4KChyKSA9PiByLmlkID09PSBpZCk7XG4gIGlmIChpZHggPj0gMCkge1xuICAgIHJlcG9ydHNbaWR4XS5zdGF0dXMgPSBzdGF0dXM7XG4gICAgd3JpdGUocmVwb3J0cyk7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbW92ZVJlcG9ydChpZDogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gIGNvbnN0IHJlcG9ydHMgPSByZWFkKCkuZmlsdGVyKChyKSA9PiByLmlkICE9PSBpZCk7XG4gIHdyaXRlKHJlcG9ydHMpO1xufVxuXG4vLyBDbGFzc2lmaWNhdGlvblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsYXNzaWZ5UmVwb3J0KHBhcmFtczoge1xuICBmaWxlOiBGaWxlO1xuICB0aXRsZT86IHN0cmluZztcbiAgZGVzY3JpcHRpb24/OiBzdHJpbmc7XG59KTogUHJvbWlzZTx7XG4gIGNhdGVnb3J5OiBpbXBvcnQoXCIuL3R5cGVzXCIpLkNhdGVnb3J5O1xuICBjb25maWRlbmNlOiBudW1iZXI7XG4gIHJlYXNvbjogc3RyaW5nO1xufT4ge1xuICBjb25zdCB0ZXh0ID0gYCR7cGFyYW1zLnRpdGxlID8/IFwiXCJ9ICR7XG4gICAgcGFyYW1zLmRlc2NyaXB0aW9uID8/IFwiXCJcbiAgfWAudG9Mb3dlckNhc2UoKTtcbiAgY29uc3Qga2V5d29yZE1hdGNoID0ga2V5d29yZENsYXNzaWZpZXIodGV4dCk7XG4gIGlmIChrZXl3b3JkTWF0Y2gpIHtcbiAgICBhd2FpdCBkZWxheSgzMDApO1xuICAgIHJldHVybiB7XG4gICAgICBjYXRlZ29yeToga2V5d29yZE1hdGNoLmNhdGVnb3J5LFxuICAgICAgY29uZmlkZW5jZTogMC45MixcbiAgICAgIHJlYXNvbjoga2V5d29yZE1hdGNoLnJlYXNvbixcbiAgICB9O1xuICB9XG5cbiAgLy8gV2VhayBkZWZhdWx0XG4gIGF3YWl0IGRlbGF5KDQwMCk7XG4gIHJldHVybiB7XG4gICAgY2F0ZWdvcnk6IFwib3RoZXJcIixcbiAgICBjb25maWRlbmNlOiAwLjQsXG4gICAgcmVhc29uOiBcIk5vIHN0cm9uZyBzaWduYWwgZm91bmQgZnJvbSB0ZXh0IG9yIGltYWdlXCIsXG4gIH07XG59XG5cbmZ1bmN0aW9uIGtleXdvcmRDbGFzc2lmaWVyKFxuICB0ZXh0OiBzdHJpbmdcbik6IHsgY2F0ZWdvcnk6IGltcG9ydChcIi4vdHlwZXNcIikuQ2F0ZWdvcnk7IHJlYXNvbjogc3RyaW5nIH0gfCBudWxsIHtcbiAgY29uc3QgaGl0ID0gKHdvcmRzOiBzdHJpbmdbXSkgPT4gd29yZHMuc29tZSgodykgPT4gdGV4dC5pbmNsdWRlcyh3KSk7XG4gIGlmIChcbiAgICBoaXQoW1xuICAgICAgXCJwb3Rob2xlXCIsXG4gICAgICBcInBvdGhvbGVzXCIsXG4gICAgICBcInJvYWQgaG9sZVwiLFxuICAgICAgXCJhc3BoYWx0XCIsXG4gICAgICBcImNyYWNrXCIsXG4gICAgICBcImNyYWNrZWQgcm9hZFwiLFxuICAgICAgXCJkYW1hZ2VkIHJvYWRcIixcbiAgICBdKVxuICApIHtcbiAgICByZXR1cm4geyBjYXRlZ29yeTogXCJwb3Rob2xlXCIsIHJlYXNvbjogXCJNYXRjaGVkIHBvdGhvbGUtcmVsYXRlZCBrZXl3b3Jkc1wiIH07XG4gIH1cbiAgaWYgKFxuICAgIGhpdChbXG4gICAgICBcImdhcmJhZ2VcIixcbiAgICAgIFwidHJhc2hcIixcbiAgICAgIFwid2FzdGVcIixcbiAgICAgIFwiZHVtcFwiLFxuICAgICAgXCJsaXR0ZXJcIixcbiAgICAgIFwiYmluIG92ZXJmbG93XCIsXG4gICAgICBcIm92ZXJmbG93aW5nXCIsXG4gICAgXSlcbiAgKSB7XG4gICAgcmV0dXJuIHsgY2F0ZWdvcnk6IFwiZ2FyYmFnZVwiLCByZWFzb246IFwiTWF0Y2hlZCBnYXJiYWdlLXJlbGF0ZWQga2V5d29yZHNcIiB9O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBhc3luYyBmdW5jdGlvbiBhdmVyYWdlQnJpZ2h0bmVzcyhmaWxlOiBGaWxlKTogUHJvbWlzZTxudW1iZXI+IHtcbi8vICAgY29uc3QgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKVxuLy8gICB0cnkge1xuLy8gICAgIGNvbnN0IGltZyA9IGF3YWl0IGxvYWRJbWFnZSh1cmwpXG4vLyAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBpbWdcbi8vICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpXG4vLyAgICAgY2FudmFzLndpZHRoID0gNjRcbi8vICAgICBjYW52YXMuaGVpZ2h0ID0gNjRcbi8vICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpXG4vLyAgICAgaWYgKCFjdHgpIHRocm93IG5ldyBFcnJvcihcIkNhbnZhcyBub3Qgc3VwcG9ydGVkXCIpXG4vLyAgICAgLy8gRHJhdyBzY2FsZWQgdGh1bWJuYWlsIHRvIHNwZWVkIHVwXG4vLyAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcbi8vICAgICBjb25zdCBkYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpLmRhdGFcbi8vICAgICBsZXQgc3VtID0gMFxuLy8gICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuLy8gICAgICAgY29uc3QgciA9IGRhdGFbaV1cbi8vICAgICAgIGNvbnN0IGcgPSBkYXRhW2kgKyAxXVxuLy8gICAgICAgY29uc3QgYiA9IGRhdGFbaSArIDJdXG4vLyAgICAgICAvLyBwZXJjZWl2ZWQgbHVtaW5hbmNlXG4vLyAgICAgICBjb25zdCB5ID0gMC4yMTI2ICogciArIDAuNzE1MiAqIGcgKyAwLjA3MjIgKiBiXG4vLyAgICAgICBzdW0gKz0geVxuLy8gICAgIH1cbi8vICAgICBjb25zdCBhdmcgPSBzdW0gLyAoZGF0YS5sZW5ndGggLyA0KVxuLy8gICAgIHJldHVybiBhdmdcbi8vICAgfSBmaW5hbGx5IHtcbi8vICAgICBVUkwucmV2b2tlT2JqZWN0VVJMKHVybClcbi8vICAgfVxuLy8gfVxuXG5mdW5jdGlvbiBsb2FkSW1hZ2Uoc3JjOiBzdHJpbmcpOiBQcm9taXNlPEhUTUxJbWFnZUVsZW1lbnQ+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcuY3Jvc3NPcmlnaW4gPSBcImFub255bW91c1wiO1xuICAgIGltZy5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKGltZyk7XG4gICAgaW1nLm9uZXJyb3IgPSAoZSkgPT4gcmVqZWN0KGUpO1xuICAgIGltZy5zcmMgPSBzcmM7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZWxheShtczogbnVtYmVyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzKSA9PiBzZXRUaW1lb3V0KHJlcywgbXMpKTtcbn1cblxuLy8gU2VlZCBkYXRhIHRvIHZpc3VhbGl6ZSBoZWF0bWFwIG9uIGZpcnN0IGxvYWRcbmZ1bmN0aW9uIHNlZWRSZXBvcnRzKCk6IFJlcG9ydFtdIHtcbiAgY29uc3QgYmFzZTogT21pdDxSZXBvcnQsIFwiaWRcIiB8IFwiY3JlYXRlZEF0XCI+W10gPSBbXG4gICAge1xuICAgICAgdGl0bGU6IFwiUG90aG9sZSBuZWFyIENvbm5hdWdodCBQbGFjZVwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiTGFyZ2UgcG90aG9sZSBjYXVzaW5nIHRyYWZmaWMgc2xvd2Rvd24uXCIsXG4gICAgICBjYXRlZ29yeTogXCJwb3Rob2xlXCIsXG4gICAgICBhdXRvQ2F0ZWdvcml6ZWQ6IHRydWUsXG4gICAgICBzdGF0dXM6IFwib3BlblwiLFxuICAgICAgbGF0OiAyOC42MzE1LFxuICAgICAgbG5nOiA3Ny4yMTY3LFxuICAgICAgaW1hZ2VEYXRhVXJsOiBcIlwiLFxuICAgIH0sXG4gICAge1xuICAgICAgdGl0bGU6IFwiT3ZlcmZsb3dpbmcgZ2FyYmFnZSBiaW5cIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIk5lZWRzIGltbWVkaWF0ZSBjbGVhbnVwLlwiLFxuICAgICAgY2F0ZWdvcnk6IFwiZ2FyYmFnZVwiLFxuICAgICAgYXV0b0NhdGVnb3JpemVkOiB0cnVlLFxuICAgICAgc3RhdHVzOiBcImluX3Byb2dyZXNzXCIsXG4gICAgICBsYXQ6IDI4LjY0NDgsXG4gICAgICBsbmc6IDc3LjIxNjcsXG4gICAgICBpbWFnZURhdGFVcmw6IFwiXCIsXG4gICAgfSxcbiAgXTtcbiAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgY29uc3QgcmVwb3J0czogUmVwb3J0W10gPSBiYXNlLm1hcCgoYiwgaSkgPT4gKHtcbiAgICAuLi5iLFxuICAgIGlkOiBuYW5vaWQoKSxcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKG5vdyAtIGkgKiAxMDAwICogNjAgKiA2MCAqIDEyKS50b0lTT1N0cmluZygpLFxuICB9KSk7XG4gIC8vIEFkZCBhIGZldyByYW5kb20gcG9pbnRzIGFyb3VuZCBjZW50ZXJcbiAgY29uc3QgY2VudGVyID0geyBsYXQ6IDI4LjYxMzksIGxuZzogNzcuMjA5IH07XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMjA7IGkrKykge1xuICAgIGNvbnN0IGppdHRlciA9IChtYXg6IG51bWJlcikgPT4gKE1hdGgucmFuZG9tKCkgLSAwLjUpICogbWF4O1xuICAgIGNvbnN0IGNhdHM6IFJlcG9ydFtcImNhdGVnb3J5XCJdW10gPSBbXCJwb3Rob2xlXCIsIFwiZ2FyYmFnZVwiLCBcIm90aGVyXCJdO1xuICAgIGNvbnN0IGNhdCA9IGNhdHNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2F0cy5sZW5ndGgpXTtcbiAgICByZXBvcnRzLnB1c2goe1xuICAgICAgaWQ6IG5hbm9pZCgpLFxuICAgICAgdGl0bGU6IFwiU2FtcGxlIHJlcG9ydFwiLFxuICAgICAgZGVzY3JpcHRpb246IFwiU2VlZGVkIGRlbW8gZGF0YVwiLFxuICAgICAgY2F0ZWdvcnk6IGNhdCxcbiAgICAgIGF1dG9DYXRlZ29yaXplZDogdHJ1ZSxcbiAgICAgIHN0YXR1czpcbiAgICAgICAgTWF0aC5yYW5kb20oKSA8IDAuMlxuICAgICAgICAgID8gXCJyZXNvbHZlZFwiXG4gICAgICAgICAgOiBNYXRoLnJhbmRvbSgpIDwgMC42XG4gICAgICAgICAgPyBcIm9wZW5cIlxuICAgICAgICAgIDogXCJpbl9wcm9ncmVzc1wiLFxuICAgICAgbGF0OiBjZW50ZXIubGF0ICsgaml0dGVyKDAuMTIpLFxuICAgICAgbG5nOiBjZW50ZXIubG5nICsgaml0dGVyKDAuMTIpLFxuICAgICAgaW1hZ2VEYXRhVXJsOiBcIlwiLFxuICAgICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShcbiAgICAgICAgbm93IC0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMCAqIDYwICogNjAgKiAyNCAqIDIwKVxuICAgICAgKS50b0lTT1N0cmluZygpLFxuICAgIH0pO1xuICB9XG4gIHJldHVybiByZXBvcnRzO1xufVxuIl0sIm5hbWVzIjpbIm5hbm9pZCIsIlNUT1JBR0VfS0VZIiwicmVhZCIsInJhdyIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJzZWVkZWQiLCJzZWVkUmVwb3J0cyIsInNldEl0ZW0iLCJKU09OIiwic3RyaW5naWZ5IiwicGFyc2UiLCJ3cml0ZSIsInJlcG9ydHMiLCJnZXRSZXBvcnRzIiwiYWRkUmVwb3J0IiwiaW5wdXQiLCJyZXBvcnQiLCJpZCIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJjYXRlZ29yeSIsImF1dG9DYXRlZ29yaXplZCIsInN0YXR1cyIsImxhdCIsImxuZyIsImltYWdlRGF0YVVybCIsImNyZWF0ZWRBdCIsIkRhdGUiLCJ0b0lTT1N0cmluZyIsInB1c2giLCJyZXMiLCJmZXRjaCIsIm1ldGhvZCIsImJvZHkiLCJ1cGRhdGVSZXBvcnRTdGF0dXMiLCJpZHgiLCJmaW5kSW5kZXgiLCJyIiwicmVtb3ZlUmVwb3J0IiwiZmlsdGVyIiwiY2xhc3NpZnlSZXBvcnQiLCJwYXJhbXMiLCJ0ZXh0IiwidG9Mb3dlckNhc2UiLCJrZXl3b3JkTWF0Y2giLCJrZXl3b3JkQ2xhc3NpZmllciIsImRlbGF5IiwiY29uZmlkZW5jZSIsInJlYXNvbiIsImhpdCIsIndvcmRzIiwic29tZSIsInciLCJpbmNsdWRlcyIsImxvYWRJbWFnZSIsInNyYyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiaW1nIiwiSW1hZ2UiLCJjcm9zc09yaWdpbiIsIm9ubG9hZCIsIm9uZXJyb3IiLCJlIiwibXMiLCJzZXRUaW1lb3V0IiwiYmFzZSIsIm5vdyIsIm1hcCIsImIiLCJpIiwiY2VudGVyIiwiaml0dGVyIiwibWF4IiwiTWF0aCIsInJhbmRvbSIsImNhdHMiLCJjYXQiLCJmbG9vciIsImxlbmd0aCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/reports-service.ts\n"));

/***/ })

});