"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./services/reports-service.ts":
/*!*************************************!*\
  !*** ./services/reports-service.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addReport: () => (/* binding */ addReport),\n/* harmony export */   classifyReport: () => (/* binding */ classifyReport),\n/* harmony export */   getReports: () => (/* binding */ getReports),\n/* harmony export */   removeReport: () => (/* binding */ removeReport),\n/* harmony export */   updateReportStatus: () => (/* binding */ updateReportStatus)\n/* harmony export */ });\n/* harmony import */ var _lib_id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/id */ \"(app-pages-browser)/./lib/id.ts\");\n/* __next_internal_client_entry_do_not_use__ getReports,addReport,updateReportStatus,removeReport,classifyReport auto */ \n// Storage\nconst STORAGE_KEY = \"smart_city_reports_v1\";\nfunction read() {\n    try {\n        const raw = localStorage.getItem(STORAGE_KEY);\n        if (!raw) {\n            const seeded = seedReports();\n            localStorage.setItem(STORAGE_KEY, JSON.stringify(seeded));\n            return seeded;\n        }\n        return JSON.parse(raw);\n    } catch (e) {\n        return [];\n    }\n}\nfunction write(reports) {\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(reports));\n}\n// Public API\nasync function getReports() {\n    return read();\n}\nasync function addReport(input) {\n    const reports = read();\n    var _input_autoCategorized;\n    const report = {\n        id: (0,_lib_id__WEBPACK_IMPORTED_MODULE_0__.nanoid)(),\n        title: input.title,\n        description: input.description,\n        category: input.category,\n        autoCategorized: (_input_autoCategorized = input.autoCategorized) !== null && _input_autoCategorized !== void 0 ? _input_autoCategorized : false,\n        status: \"open\",\n        lat: input.lat,\n        lng: input.lng,\n        imageDataUrl: input.imageDataUrl,\n        createdAt: new Date().toISOString()\n    };\n    reports.push(report);\n    write(reports);\n    const res = await fetch(\"/api/reports\", {\n        method: \"POST\",\n        body: JSON.stringify(report)\n    });\n    return report;\n}\nasync function updateReportStatus(id, status) {\n    const reports = read();\n    const idx = reports.findIndex((r)=>r.id === id);\n    if (idx >= 0) {\n        reports[idx].status = status;\n        write(reports);\n    }\n}\nasync function removeReport(id) {\n    const reports = read().filter((r)=>r.id !== id);\n    write(reports);\n}\n// Classification\nasync function classifyReport(params) {\n    var _params_title, _params_description;\n    const text = \"\".concat((_params_title = params.title) !== null && _params_title !== void 0 ? _params_title : \"\", \" \").concat((_params_description = params.description) !== null && _params_description !== void 0 ? _params_description : \"\").toLowerCase();\n    const keywordMatch = keywordClassifier(text);\n    if (keywordMatch) {\n        await delay(300);\n        return {\n            category: keywordMatch.category,\n            confidence: 0.92,\n            reason: keywordMatch.reason\n        };\n    }\n    // Weak default\n    await delay(400);\n    return {\n        category: \"other\",\n        confidence: 0.4,\n        reason: \"No strong signal found from text or image\"\n    };\n}\nfunction keywordClassifier(text) {\n    const hit = (words)=>words.some((w)=>text.includes(w));\n    if (hit([\n        \"pothole\",\n        \"potholes\",\n        \"road hole\",\n        \"asphalt\",\n        \"crack\",\n        \"cracked road\",\n        \"damaged road\"\n    ])) {\n        return {\n            category: \"pothole\",\n            reason: \"Matched pothole-related keywords\"\n        };\n    }\n    if (hit([\n        \"garbage\",\n        \"trash\",\n        \"waste\",\n        \"dump\",\n        \"litter\",\n        \"bin overflow\",\n        \"overflowing\"\n    ])) {\n        return {\n            category: \"garbage\",\n            reason: \"Matched garbage-related keywords\"\n        };\n    }\n    return null;\n}\n// async function averageBrightness(file: File): Promise<number> {\n//   const url = URL.createObjectURL(file)\n//   try {\n//     const img = await loadImage(url)\n//     const { width, height } = img\n//     const canvas = document.createElement(\"canvas\")\n//     canvas.width = 64\n//     canvas.height = 64\n//     const ctx = canvas.getContext(\"2d\")\n//     if (!ctx) throw new Error(\"Canvas not supported\")\n//     // Draw scaled thumbnail to speed up\n//     ctx.drawImage(img, 0, 0, canvas.width, canvas.height)\n//     const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data\n//     let sum = 0\n//     for (let i = 0; i < data.length; i += 4) {\n//       const r = data[i]\n//       const g = data[i + 1]\n//       const b = data[i + 2]\n//       // perceived luminance\n//       const y = 0.2126 * r + 0.7152 * g + 0.0722 * b\n//       sum += y\n//     }\n//     const avg = sum / (data.length / 4)\n//     return avg\n//   } finally {\n//     URL.revokeObjectURL(url)\n//   }\n// }\nfunction loadImage(src) {\n    return new Promise((resolve, reject)=>{\n        const img = new Image();\n        img.crossOrigin = \"anonymous\";\n        img.onload = ()=>resolve(img);\n        img.onerror = (e)=>reject(e);\n        img.src = src;\n    });\n}\nfunction delay(ms) {\n    return new Promise((res)=>setTimeout(res, ms));\n}\n// Seed data to visualize heatmap on first load\nfunction seedReports() {\n    const base = [\n        {\n            title: \"Pothole near Connaught Place\",\n            description: \"Large pothole causing traffic slowdown.\",\n            category: \"pothole\",\n            autoCategorized: true,\n            status: \"open\",\n            lat: 28.6315,\n            lng: 77.2167,\n            imageDataUrl: \"\"\n        },\n        {\n            title: \"Overflowing garbage bin\",\n            description: \"Needs immediate cleanup.\",\n            category: \"garbage\",\n            autoCategorized: true,\n            status: \"in_progress\",\n            lat: 28.6448,\n            lng: 77.2167,\n            imageDataUrl: \"\"\n        }\n    ];\n    const now = Date.now();\n    const reports = base.map((b, i)=>({\n            ...b,\n            id: (0,_lib_id__WEBPACK_IMPORTED_MODULE_0__.nanoid)(),\n            createdAt: new Date(now - i * 1000 * 60 * 60 * 12).toISOString()\n        }));\n    // Add a few random points around center\n    const center = {\n        lat: 28.6139,\n        lng: 77.209\n    };\n    for(let i = 0; i < 20; i++){\n        const jitter = (max)=>(Math.random() - 0.5) * max;\n        const cats = [\n            \"pothole\",\n            \"garbage\",\n            \"other\"\n        ];\n        const cat = cats[Math.floor(Math.random() * cats.length)];\n        reports.push({\n            id: (0,_lib_id__WEBPACK_IMPORTED_MODULE_0__.nanoid)(),\n            title: \"Sample report\",\n            description: \"Seeded demo data\",\n            category: cat,\n            autoCategorized: true,\n            status: Math.random() < 0.2 ? \"resolved\" : Math.random() < 0.6 ? \"open\" : \"in_progress\",\n            lat: center.lat + jitter(0.12),\n            lng: center.lng + jitter(0.12),\n            imageDataUrl: \"\",\n            createdAt: new Date(now - Math.floor(Math.random() * 1000 * 60 * 60 * 24 * 20)).toISOString()\n        });\n    }\n    return reports;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL3JlcG9ydHMtc2VydmljZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7eUhBRW1DO0FBS25DLFVBQVU7QUFDVixNQUFNQyxjQUFjO0FBRXBCLFNBQVNDO0lBQ1AsSUFBSTtRQUNGLE1BQU1DLE1BQU1DLGFBQWFDLE9BQU8sQ0FBQ0o7UUFDakMsSUFBSSxDQUFDRSxLQUFLO1lBQ1IsTUFBTUcsU0FBU0M7WUFDZkgsYUFBYUksT0FBTyxDQUFDUCxhQUFhUSxLQUFLQyxTQUFTLENBQUNKO1lBQ2pELE9BQU9BO1FBQ1Q7UUFDQSxPQUFPRyxLQUFLRSxLQUFLLENBQUNSO0lBQ3BCLEVBQUUsVUFBTTtRQUNOLE9BQU8sRUFBRTtJQUNYO0FBQ0Y7QUFFQSxTQUFTUyxNQUFNQyxPQUFpQjtJQUM5QlQsYUFBYUksT0FBTyxDQUFDUCxhQUFhUSxLQUFLQyxTQUFTLENBQUNHO0FBQ25EO0FBRUEsYUFBYTtBQUNOLGVBQWVDO0lBQ3BCLE9BQU9aO0FBQ1Q7QUFFTyxlQUFlYSxVQUNwQkMsS0FBb0M7SUFFcEMsTUFBTUgsVUFBVVg7UUFNR2M7SUFMbkIsTUFBTUMsU0FBaUI7UUFDckJDLElBQUlsQiwrQ0FBTUE7UUFDVm1CLE9BQU9ILE1BQU1HLEtBQUs7UUFDbEJDLGFBQWFKLE1BQU1JLFdBQVc7UUFDOUJDLFVBQVVMLE1BQU1LLFFBQVE7UUFDeEJDLGlCQUFpQk4sQ0FBQUEseUJBQUFBLE1BQU1NLGVBQWUsY0FBckJOLG9DQUFBQSx5QkFBeUI7UUFDMUNPLFFBQVE7UUFDUkMsS0FBS1IsTUFBTVEsR0FBRztRQUNkQyxLQUFLVCxNQUFNUyxHQUFHO1FBQ2RDLGNBQWNWLE1BQU1VLFlBQVk7UUFDaENDLFdBQVcsSUFBSUMsT0FBT0MsV0FBVztJQUNuQztJQUNBaEIsUUFBUWlCLElBQUksQ0FBQ2I7SUFDYkwsTUFBTUM7SUFFTixNQUFNa0IsTUFBTSxNQUFNQyxNQUFNLGdCQUFnQjtRQUN0Q0MsUUFBUTtRQUNSQyxNQUFNekIs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QUFHLEdBQUdpRCxPQUFPO1lBQ3pCaEQsY0FBYztZQUNkQyxXQUFXLElBQUlDLEtBQ2J5QyxNQUFNTyxLQUFLSSxLQUFLLENBQUNKLEtBQUtDLE1BQU0sS0FBSyxPQUFPLEtBQUssS0FBSyxLQUFLLEtBQ3ZEaEQsV0FBVztRQUNmO0lBQ0Y7SUFDQSxPQUFPaEI7QUFDVCIsInNvdXJjZXMiOlsiRTpcXFBST0pFQ1RTXFw3dGggU2VtZXN0ZXJcXFNtYXJ0LUNpdHktSXNzdWUtUmVwb3J0ZXItLW1haW5cXHNlcnZpY2VzXFxyZXBvcnRzLXNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCB7IG5hbm9pZCB9IGZyb20gXCIuLi9saWIvaWRcIjtcbmltcG9ydCB0eXBlIHsgUmVwb3J0IH0gZnJvbSBcIi4vdHlwZXNcIjtcbmV4cG9ydCB0eXBlIHsgUmVwb3J0IH0gZnJvbSBcIi4vdHlwZXNcIjtcbmV4cG9ydCB0eXBlIHsgQ2F0ZWdvcnksIFN0YXR1cywgUmVwb3J0SW5wdXQgfSBmcm9tIFwiLi90eXBlc1wiO1xuXG4vLyBTdG9yYWdlXG5jb25zdCBTVE9SQUdFX0tFWSA9IFwic21hcnRfY2l0eV9yZXBvcnRzX3YxXCI7XG5cbmZ1bmN0aW9uIHJlYWQoKTogUmVwb3J0W10ge1xuICB0cnkge1xuICAgIGNvbnN0IHJhdyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFNUT1JBR0VfS0VZKTtcbiAgICBpZiAoIXJhdykge1xuICAgICAgY29uc3Qgc2VlZGVkID0gc2VlZFJlcG9ydHMoKTtcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShzZWVkZWQpKTtcbiAgICAgIHJldHVybiBzZWVkZWQ7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnBhcnNlKHJhdykgYXMgUmVwb3J0W107XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3cml0ZShyZXBvcnRzOiBSZXBvcnRbXSkge1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWSwgSlNPTi5zdHJpbmdpZnkocmVwb3J0cykpO1xufVxuXG4vLyBQdWJsaWMgQVBJXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UmVwb3J0cygpOiBQcm9taXNlPFJlcG9ydFtdPiB7XG4gIHJldHVybiByZWFkKCk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhZGRSZXBvcnQoXG4gIGlucHV0OiBpbXBvcnQoXCIuL3R5cGVzXCIpLlJlcG9ydElucHV0XG4pOiBQcm9taXNlPFJlcG9ydD4ge1xuICBjb25zdCByZXBvcnRzID0gcmVhZCgpO1xuICBjb25zdCByZXBvcnQ6IFJlcG9ydCA9IHtcbiAgICBpZDogbmFub2lkKCksXG4gICAgdGl0bGU6IGlucHV0LnRpdGxlLFxuICAgIGRlc2NyaXB0aW9uOiBpbnB1dC5kZXNjcmlwdGlvbixcbiAgICBjYXRlZ29yeTogaW5wdXQuY2F0ZWdvcnksXG4gICAgYXV0b0NhdGVnb3JpemVkOiBpbnB1dC5hdXRvQ2F0ZWdvcml6ZWQgPz8gZmFsc2UsXG4gICAgc3RhdHVzOiBcIm9wZW5cIixcbiAgICBsYXQ6IGlucHV0LmxhdCxcbiAgICBsbmc6IGlucHV0LmxuZyxcbiAgICBpbWFnZURhdGFVcmw6IGlucHV0LmltYWdlRGF0YVVybCxcbiAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgfTtcbiAgcmVwb3J0cy5wdXNoKHJlcG9ydCk7XG4gIHdyaXRlKHJlcG9ydHMpO1xuXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKFwiL2FwaS9yZXBvcnRzXCIsIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcG9ydCksXG4gIH0pO1xuXG4gIHJldHVybiByZXBvcnQ7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB1cGRhdGVSZXBvcnRTdGF0dXMoXG4gIGlkOiBzdHJpbmcsXG4gIHN0YXR1czogaW1wb3J0KFwiLi90eXBlc1wiKS5TdGF0dXNcbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCByZXBvcnRzID0gcmVhZCgpO1xuICBjb25zdCBpZHggPSByZXBvcnRzLmZpbmRJbmRleCgocikgPT4gci5pZCA9PT0gaWQpO1xuICBpZiAoaWR4ID49IDApIHtcbiAgICByZXBvcnRzW2lkeF0uc3RhdHVzID0gc3RhdHVzO1xuICAgIHdyaXRlKHJlcG9ydHMpO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW1vdmVSZXBvcnQoaWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCByZXBvcnRzID0gcmVhZCgpLmZpbHRlcigocikgPT4gci5pZCAhPT0gaWQpO1xuICB3cml0ZShyZXBvcnRzKTtcbn1cblxuLy8gQ2xhc3NpZmljYXRpb25cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjbGFzc2lmeVJlcG9ydChwYXJhbXM6IHtcbiAgZmlsZTogRmlsZTtcbiAgdGl0bGU/OiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uPzogc3RyaW5nO1xufSk6IFByb21pc2U8e1xuICBjYXRlZ29yeTogaW1wb3J0KFwiLi90eXBlc1wiKS5DYXRlZ29yeTtcbiAgY29uZmlkZW5jZTogbnVtYmVyO1xuICByZWFzb246IHN0cmluZztcbn0+IHtcbiAgY29uc3QgdGV4dCA9IGAke3BhcmFtcy50aXRsZSA/PyBcIlwifSAke1xuICAgIHBhcmFtcy5kZXNjcmlwdGlvbiA/PyBcIlwiXG4gIH1gLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGtleXdvcmRNYXRjaCA9IGtleXdvcmRDbGFzc2lmaWVyKHRleHQpO1xuICBpZiAoa2V5d29yZE1hdGNoKSB7XG4gICAgYXdhaXQgZGVsYXkoMzAwKTtcbiAgICByZXR1cm4ge1xuICAgICAgY2F0ZWdvcnk6IGtleXdvcmRNYXRjaC5jYXRlZ29yeSxcbiAgICAgIGNvbmZpZGVuY2U6IDAuOTIsXG4gICAgICByZWFzb246IGtleXdvcmRNYXRjaC5yZWFzb24sXG4gICAgfTtcbiAgfVxuXG4gIC8vIFdlYWsgZGVmYXVsdFxuICBhd2FpdCBkZWxheSg0MDApO1xuICByZXR1cm4ge1xuICAgIGNhdGVnb3J5OiBcIm90aGVyXCIsXG4gICAgY29uZmlkZW5jZTogMC40LFxuICAgIHJlYXNvbjogXCJObyBzdHJvbmcgc2lnbmFsIGZvdW5kIGZyb20gdGV4dCBvciBpbWFnZVwiLFxuICB9O1xufVxuXG5mdW5jdGlvbiBrZXl3b3JkQ2xhc3NpZmllcihcbiAgdGV4dDogc3RyaW5nXG4pOiB7IGNhdGVnb3J5OiBpbXBvcnQoXCIuL3R5cGVzXCIpLkNhdGVnb3J5OyByZWFzb246IHN0cmluZyB9IHwgbnVsbCB7XG4gIGNvbnN0IGhpdCA9ICh3b3Jkczogc3RyaW5nW10pID0+IHdvcmRzLnNvbWUoKHcpID0+IHRleHQuaW5jbHVkZXModykpO1xuICBpZiAoXG4gICAgaGl0KFtcbiAgICAgIFwicG90aG9sZVwiLFxuICAgICAgXCJwb3Rob2xlc1wiLFxuICAgICAgXCJyb2FkIGhvbGVcIixcbiAgICAgIFwiYXNwaGFsdFwiLFxuICAgICAgXCJjcmFja1wiLFxuICAgICAgXCJjcmFja2VkIHJvYWRcIixcbiAgICAgIFwiZGFtYWdlZCByb2FkXCIsXG4gICAgXSlcbiAgKSB7XG4gICAgcmV0dXJuIHsgY2F0ZWdvcnk6IFwicG90aG9sZVwiLCByZWFzb246IFwiTWF0Y2hlZCBwb3Rob2xlLXJlbGF0ZWQga2V5d29yZHNcIiB9O1xuICB9XG4gIGlmIChcbiAgICBoaXQoW1xuICAgICAgXCJnYXJiYWdlXCIsXG4gICAgICBcInRyYXNoXCIsXG4gICAgICBcIndhc3RlXCIsXG4gICAgICBcImR1bXBcIixcbiAgICAgIFwibGl0dGVyXCIsXG4gICAgICBcImJpbiBvdmVyZmxvd1wiLFxuICAgICAgXCJvdmVyZmxvd2luZ1wiLFxuICAgIF0pXG4gICkge1xuICAgIHJldHVybiB7IGNhdGVnb3J5OiBcImdhcmJhZ2VcIiwgcmVhc29uOiBcIk1hdGNoZWQgZ2FyYmFnZS1yZWxhdGVkIGtleXdvcmRzXCIgfTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gYXN5bmMgZnVuY3Rpb24gYXZlcmFnZUJyaWdodG5lc3MoZmlsZTogRmlsZSk6IFByb21pc2U8bnVtYmVyPiB7XG4vLyAgIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSlcbi8vICAgdHJ5IHtcbi8vICAgICBjb25zdCBpbWcgPSBhd2FpdCBsb2FkSW1hZ2UodXJsKVxuLy8gICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gaW1nXG4vLyAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKVxuLy8gICAgIGNhbnZhcy53aWR0aCA9IDY0XG4vLyAgICAgY2FudmFzLmhlaWdodCA9IDY0XG4vLyAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKVxuLy8gICAgIGlmICghY3R4KSB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgbm90IHN1cHBvcnRlZFwiKVxuLy8gICAgIC8vIERyYXcgc2NhbGVkIHRodW1ibmFpbCB0byBzcGVlZCB1cFxuLy8gICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG4vLyAgICAgY29uc3QgZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KS5kYXRhXG4vLyAgICAgbGV0IHN1bSA9IDBcbi8vICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbi8vICAgICAgIGNvbnN0IHIgPSBkYXRhW2ldXG4vLyAgICAgICBjb25zdCBnID0gZGF0YVtpICsgMV1cbi8vICAgICAgIGNvbnN0IGIgPSBkYXRhW2kgKyAyXVxuLy8gICAgICAgLy8gcGVyY2VpdmVkIGx1bWluYW5jZVxuLy8gICAgICAgY29uc3QgeSA9IDAuMjEyNiAqIHIgKyAwLjcxNTIgKiBnICsgMC4wNzIyICogYlxuLy8gICAgICAgc3VtICs9IHlcbi8vICAgICB9XG4vLyAgICAgY29uc3QgYXZnID0gc3VtIC8gKGRhdGEubGVuZ3RoIC8gNClcbi8vICAgICByZXR1cm4gYXZnXG4vLyAgIH0gZmluYWxseSB7XG4vLyAgICAgVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpXG4vLyAgIH1cbi8vIH1cblxuZnVuY3Rpb24gbG9hZEltYWdlKHNyYzogc3RyaW5nKTogUHJvbWlzZTxIVE1MSW1hZ2VFbGVtZW50PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgaW1nLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcbiAgICBpbWcub25sb2FkID0gKCkgPT4gcmVzb2x2ZShpbWcpO1xuICAgIGltZy5vbmVycm9yID0gKGUpID0+IHJlamVjdChlKTtcbiAgICBpbWcuc3JjID0gc3JjO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVsYXkobXM6IG51bWJlcikge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlcykgPT4gc2V0VGltZW91dChyZXMsIG1zKSk7XG59XG5cbi8vIFNlZWQgZGF0YSB0byB2aXN1YWxpemUgaGVhdG1hcCBvbiBmaXJzdCBsb2FkXG5mdW5jdGlvbiBzZWVkUmVwb3J0cygpOiBSZXBvcnRbXSB7XG4gIGNvbnN0IGJhc2U6IE9taXQ8UmVwb3J0LCBcImlkXCIgfCBcImNyZWF0ZWRBdFwiPltdID0gW1xuICAgIHtcbiAgICAgIHRpdGxlOiBcIlBvdGhvbGUgbmVhciBDb25uYXVnaHQgUGxhY2VcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIkxhcmdlIHBvdGhvbGUgY2F1c2luZyB0cmFmZmljIHNsb3dkb3duLlwiLFxuICAgICAgY2F0ZWdvcnk6IFwicG90aG9sZVwiLFxuICAgICAgYXV0b0NhdGVnb3JpemVkOiB0cnVlLFxuICAgICAgc3RhdHVzOiBcIm9wZW5cIixcbiAgICAgIGxhdDogMjguNjMxNSxcbiAgICAgIGxuZzogNzcuMjE2NyxcbiAgICAgIGltYWdlRGF0YVVybDogXCJcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIHRpdGxlOiBcIk92ZXJmbG93aW5nIGdhcmJhZ2UgYmluXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJOZWVkcyBpbW1lZGlhdGUgY2xlYW51cC5cIixcbiAgICAgIGNhdGVnb3J5OiBcImdhcmJhZ2VcIixcbiAgICAgIGF1dG9DYXRlZ29yaXplZDogdHJ1ZSxcbiAgICAgIHN0YXR1czogXCJpbl9wcm9ncmVzc1wiLFxuICAgICAgbGF0OiAyOC42NDQ4LFxuICAgICAgbG5nOiA3Ny4yMTY3LFxuICAgICAgaW1hZ2VEYXRhVXJsOiBcIlwiLFxuICAgIH0sXG4gIF07XG4gIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gIGNvbnN0IHJlcG9ydHM6IFJlcG9ydFtdID0gYmFzZS5tYXAoKGIsIGkpID0+ICh7XG4gICAgLi4uYixcbiAgICBpZDogbmFub2lkKCksXG4gICAgY3JlYXRlZEF0OiBuZXcgRGF0ZShub3cgLSBpICogMTAwMCAqIDYwICogNjAgKiAxMikudG9JU09TdHJpbmcoKSxcbiAgfSkpO1xuICAvLyBBZGQgYSBmZXcgcmFuZG9tIHBvaW50cyBhcm91bmQgY2VudGVyXG4gIGNvbnN0IGNlbnRlciA9IHsgbGF0OiAyOC42MTM5LCBsbmc6IDc3LjIwOSB9O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDIwOyBpKyspIHtcbiAgICBjb25zdCBqaXR0ZXIgPSAobWF4OiBudW1iZXIpID0+IChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIG1heDtcbiAgICBjb25zdCBjYXRzOiBSZXBvcnRbXCJjYXRlZ29yeVwiXVtdID0gW1wicG90aG9sZVwiLCBcImdhcmJhZ2VcIiwgXCJvdGhlclwiXTtcbiAgICBjb25zdCBjYXQgPSBjYXRzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNhdHMubGVuZ3RoKV07XG4gICAgcmVwb3J0cy5wdXNoKHtcbiAgICAgIGlkOiBuYW5vaWQoKSxcbiAgICAgIHRpdGxlOiBcIlNhbXBsZSByZXBvcnRcIixcbiAgICAgIGRlc2NyaXB0aW9uOiBcIlNlZWRlZCBkZW1vIGRhdGFcIixcbiAgICAgIGNhdGVnb3J5OiBjYXQsXG4gICAgICBhdXRvQ2F0ZWdvcml6ZWQ6IHRydWUsXG4gICAgICBzdGF0dXM6XG4gICAgICAgIE1hdGgucmFuZG9tKCkgPCAwLjJcbiAgICAgICAgICA/IFwicmVzb2x2ZWRcIlxuICAgICAgICAgIDogTWF0aC5yYW5kb20oKSA8IDAuNlxuICAgICAgICAgID8gXCJvcGVuXCJcbiAgICAgICAgICA6IFwiaW5fcHJvZ3Jlc3NcIixcbiAgICAgIGxhdDogY2VudGVyLmxhdCArIGppdHRlcigwLjEyKSxcbiAgICAgIGxuZzogY2VudGVyLmxuZyArIGppdHRlcigwLjEyKSxcbiAgICAgIGltYWdlRGF0YVVybDogXCJcIixcbiAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoXG4gICAgICAgIG5vdyAtIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAgKiA2MCAqIDYwICogMjQgKiAyMClcbiAgICAgICkudG9JU09TdHJpbmcoKSxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVwb3J0cztcbn1cbiJdLCJuYW1lcyI6WyJuYW5vaWQiLCJTVE9SQUdFX0tFWSIsInJlYWQiLCJyYXciLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwic2VlZGVkIiwic2VlZFJlcG9ydHMiLCJzZXRJdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsInBhcnNlIiwid3JpdGUiLCJyZXBvcnRzIiwiZ2V0UmVwb3J0cyIsImFkZFJlcG9ydCIsImlucHV0IiwicmVwb3J0IiwiaWQiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwiY2F0ZWdvcnkiLCJhdXRvQ2F0ZWdvcml6ZWQiLCJzdGF0dXMiLCJsYXQiLCJsbmciLCJpbWFnZURhdGFVcmwiLCJjcmVhdGVkQXQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJwdXNoIiwicmVzIiwiZmV0Y2giLCJtZXRob2QiLCJib2R5IiwidXBkYXRlUmVwb3J0U3RhdHVzIiwiaWR4IiwiZmluZEluZGV4IiwiciIsInJlbW92ZVJlcG9ydCIsImZpbHRlciIsImNsYXNzaWZ5UmVwb3J0IiwicGFyYW1zIiwidGV4dCIsInRvTG93ZXJDYXNlIiwia2V5d29yZE1hdGNoIiwia2V5d29yZENsYXNzaWZpZXIiLCJkZWxheSIsImNvbmZpZGVuY2UiLCJyZWFzb24iLCJoaXQiLCJ3b3JkcyIsInNvbWUiLCJ3IiwiaW5jbHVkZXMiLCJsb2FkSW1hZ2UiLCJzcmMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImltZyIsIkltYWdlIiwiY3Jvc3NPcmlnaW4iLCJvbmxvYWQiLCJvbmVycm9yIiwiZSIsIm1zIiwic2V0VGltZW91dCIsImJhc2UiLCJub3ciLCJtYXAiLCJiIiwiaSIsImNlbnRlciIsImppdHRlciIsIm1heCIsIk1hdGgiLCJyYW5kb20iLCJjYXRzIiwiY2F0IiwiZmxvb3IiLCJsZW5ndGgiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/reports-service.ts\n"));

/***/ })

});